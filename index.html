<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sounds of STFU - POC</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a1a;
            color: #ffffff;
        }
        #controls {
            margin-bottom: 20px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 8px;
        }
        input, button {
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
        }
        input {
            background: #3a3a3a;
            color: #ffffff;
            min-width: 200px;
        }
        button {
            background: #4a9eff;
            color: #ffffff;
            cursor: pointer;
        }
        button:hover {
            background: #3a8eef;
        }
        button:disabled {
            background: #555555;
            cursor: not-allowed;
        }
        #status {
            margin: 10px 5px;
            padding: 10px;
            background: #333333;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        #barCanvas {
            display: block;
            background: #2a2a2a;
            border: 2px solid #4a4a4a;
            border-radius: 8px;
            cursor: crosshair;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h1>Sounds of STFU - POC</h1>
        <div>
            <input type="text" id="roomCode" placeholder="Enter room code (or create new)">
            <button id="joinRoom">Join Room</button>
        </div>
        <div>
            <button id="muteBtn" disabled>Mute</button>
            <button id="testModeToggle" style="margin-left: 10px;">Test Mode</button>
            <span id="connectionState" style="margin-left: 15px; padding: 5px 10px; background: #555; border-radius: 4px; font-size: 12px;">Not Connected</span>
            <span id="roomDisplay" style="margin-left: 15px; padding: 5px 10px; background: #3a3a3a; border-radius: 4px; font-size: 12px; font-weight: bold; display: none;">Room: <span id="roomName"></span></span>
        </div>
        <div style="margin-top: 10px;">
            <label style="margin-right: 20px;">
                Hearing Range:
                <input type="range" id="hearingRangeSlider" min="100" max="500" value="300" step="10" style="vertical-align: middle; min-width: 150px;">
                <span id="hearingRangeValue" style="display: inline-block; min-width: 60px; font-weight: bold;">300px</span>
            </label>
            <label>
                Falloff Curve:
                <input type="range" id="falloffSlider" min="0.5" max="3.0" value="1.0" step="0.1" style="vertical-align: middle; min-width: 150px;">
                <span id="falloffValue" style="display: inline-block; min-width: 40px; font-weight: bold;">1.0</span>
            </label>
        </div>
        <div id="status">Status: Not connected</div>
        <div id="participants" style="margin-top: 10px; padding: 10px; background: #333; border-radius: 4px;">
            <strong>Participants:</strong>
            <ul id="participantList" style="list-style: none; padding: 0;"></ul>
        </div>
    </div>

    <div id="instructions" style="padding: 20px; background: #2a2a2a; border-radius: 8px; margin-bottom: 20px;">
        <h3 style="margin-top: 0;">How to Use:</h3>
        <ol style="line-height: 1.8;">
            <li>Enter a room code (create new or join existing room)</li>
            <li>Click "Join Room" and allow microphone access</li>
            <li><strong>Use WASD or arrow keys to move, or click anywhere on the canvas</strong></li>
            <li>Get close to others to hear them clearly</li>
            <li>Move away to reduce their volume</li>
            <li>Adjust "Hearing Range" and "Falloff Curve" sliders to tune spatial audio</li>
            <li>Pulsing ring = someone is speaking</li>
        </ol>
        <p style="margin-top: 15px; padding: 10px; background: #3a3a3a; border-radius: 4px; margin-bottom: 0;">
            <strong>Tip:</strong> The light blue circle around you shows your hearing range.
            Move within that range to have a conversation. Adjust the sliders to experiment with different spatial audio settings.
        </p>
    </div>

    <div id="testModePanel" style="display:none; padding: 20px; background: #2a2a2a; border-radius: 8px; margin-bottom: 20px;">
        <h3 style="margin-top: 0;">Test Mode</h3>

        <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px;">
                Number of Bots:
                <input type="range" id="testBotCount" min="1" max="3" value="3" style="vertical-align: middle; margin-left: 10px;">
                <span id="testBotCountValue" style="font-weight: bold; margin-left: 10px;">3</span>
            </label>
        </div>

        <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px;">
                Duration:
                <select id="testDuration" style="margin-left: 10px;">
                    <option value="30">30 seconds</option>
                    <option value="60">1 minute</option>
                    <option value="120" selected>2 minutes</option>
                    <option value="300">5 minutes</option>
                </select>
            </label>
        </div>

        <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px;">
                Movement:
                <select id="testMovement" style="margin-left: 10px;">
                    <option value="stationary" selected>Stationary</option>
                    <option value="patterns">Patterns</option>
                </select>
            </label>
        </div>

        <div style="margin-bottom: 15px;">
            <button id="startTestBtn" style="padding: 8px 16px; font-size: 14px;">Start Test</button>
            <button id="stopTestBtn" style="display:none; margin-left: 10px; padding: 8px 16px; font-size: 14px;">Stop Test</button>
        </div>

        <div id="testTimer" style="display:none; margin-top: 10px; padding: 10px; background: #3a3a3a; border-radius: 4px; font-weight: bold; color: #4a9eff;">
            Time Remaining: <span id="testTimerValue">2:00</span>
        </div>

        <div id="testModeStatus" style="display:none; margin-top: 10px; padding: 10px; background: #3a3a3a; border-radius: 4px; font-size: 13px;">
            Test Mode Active (You are controlling)
        </div>

        <div id="demoModeStatus" style="display:none; margin-top: 10px; padding: 10px; background: #3a3a3a; border-radius: 4px; font-size: 13px;">
            Demo Mode Active (Controlled by <span id="demoHostName">UserX</span>)
        </div>
    </div>

    <canvas id="barCanvas" width="800" height="600"></canvas>

    <script src="https://unpkg.com/peerjs@1.5.0/dist/peerjs.min.js"></script>
    <script>
    let peer = null;
    let localStream = null;
    let myPeerId = null;
    let currentRoom = null;
    let connections = {}; // { peerId: { call: MediaConnection, conn: DataConnection } }
    let participants = {}; // { peerId: { name: string } }
    let isMuted = false;

    const roomCodeInput = document.getElementById('roomCode');
    const joinRoomBtn = document.getElementById('joinRoom');
    const muteBtnEl = document.getElementById('muteBtn');
    const statusDiv = document.getElementById('status');
    const participantListEl = document.getElementById('participantList');
    const connectionStateEl = document.getElementById('connectionState');
    const roomDisplayEl = document.getElementById('roomDisplay');
    const roomNameEl = document.getElementById('roomName');
    const hearingRangeSlider = document.getElementById('hearingRangeSlider');
    const hearingRangeValue = document.getElementById('hearingRangeValue');
    const falloffSlider = document.getElementById('falloffSlider');
    const falloffValue = document.getElementById('falloffValue');
    const testModeToggle = document.getElementById('testModeToggle');
    const testModePanel = document.getElementById('testModePanel');
    const testBotCount = document.getElementById('testBotCount');
    const testBotCountValue = document.getElementById('testBotCountValue');
    const testDuration = document.getElementById('testDuration');
    const testMovement = document.getElementById('testMovement');
    const startTestBtn = document.getElementById('startTestBtn');
    const stopTestBtn = document.getElementById('stopTestBtn');
    const testTimer = document.getElementById('testTimer');
    const testTimerValue = document.getElementById('testTimerValue');
    const testModeStatus = document.getElementById('testModeStatus');
    const demoModeStatus = document.getElementById('demoModeStatus');
    const demoHostName = document.getElementById('demoHostName');

    const canvas = document.getElementById('barCanvas');
    const ctx = canvas.getContext('2d');

    let positions = {}; // { peerId: { x, y } }
    let myPosition = { x: 400, y: 300 }; // Start in center

    let audioContext = null;
    let gainNodes = {}; // { peerId: GainNode }
    let analyzerNodes = {}; // { peerId: AnalyserNode }
    let speakingStates = {}; // { peerId: boolean }

    // Spatial audio parameters
    let maxHearingRange = 300; // adjustable via slider
    let falloffCurve = 1.0; // adjustable via slider (1.0 = linear, >1 = exponential)

    // Test mode state
    let testBots = {}; // { botId: {id, name, position, audioType, audioSource, gainNode, analyzerNode, pattern, patternPhase, patternCenter, isDragging} }
    let testModeState = {
        active: false,
        hostPeerId: null,
        startTime: null,
        duration: 120,
        movementMode: 'stationary',
        numBots: 3
    };
    let testTimerInterval = null;

    // Audio type cycle order
    const AUDIO_TYPES = ['silence', 'speech', 'tts', 'ambient', 'music', 'sfx'];

    // WASD and Arrow key keyboard movement
    const moveSpeed = 10; // pixels per keypress
    const keysPressed = {};

    // Test mode panel toggle
    testModeToggle.addEventListener('click', () => {
        if (testModePanel.style.display === 'none') {
            testModePanel.style.display = 'block';
        } else {
            testModePanel.style.display = 'none';
        }
    });

    // Bot count slider updates value display
    testBotCount.addEventListener('input', () => {
        testBotCountValue.textContent = testBotCount.value;
    });

    document.addEventListener('keydown', (e) => {
        if (!myPeerId) return;

        const key = e.key.toLowerCase();
        // Track WASD and arrow keys
        if (['w', 's', 'a', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key)) {
            keysPressed[key] = true;
            e.preventDefault(); // Prevent page scrolling with arrow keys
        }
    });

    document.addEventListener('keyup', (e) => {
        const key = e.key.toLowerCase();
        keysPressed[key] = false;
    });

    // Update position based on keys pressed
    function handleKeyboardMovement() {
        if (!myPeerId) return;

        let moved = false;

        // WASD or Arrow keys
        if (keysPressed['w'] || keysPressed['arrowup']) {
            myPosition.y = Math.max(0, myPosition.y - moveSpeed);
            moved = true;
        }
        if (keysPressed['s'] || keysPressed['arrowdown']) {
            myPosition.y = Math.min(canvas.height, myPosition.y + moveSpeed);
            moved = true;
        }
        if (keysPressed['a'] || keysPressed['arrowleft']) {
            myPosition.x = Math.max(0, myPosition.x - moveSpeed);
            moved = true;
        }
        if (keysPressed['d'] || keysPressed['arrowright']) {
            myPosition.x = Math.min(canvas.width, myPosition.x + moveSpeed);
            moved = true;
        }

        if (moved) {
            positions[myPeerId] = myPosition;
            broadcastPosition();
            updateSpatialAudio();
        }
    }

    // Canvas click to move
    canvas.addEventListener('click', (e) => {
        if (!myPeerId) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        myPosition = { x, y };
        positions[myPeerId] = myPosition;

        // Broadcast position to all peers
        broadcastPosition();

        // Update spatial audio based on new position
        updateSpatialAudio();

        draw();
    });

    // ========== Bot Management Functions ==========

    // Create a bot object
    function createBot(botId, botNumber, position) {
        return {
            id: botId,
            name: `BOT ${botNumber} ðŸ¤–`,
            position: position,
            audioType: 'silence',
            audioSource: null,
            gainNode: null,
            analyzerNode: null,
            stream: null,
            pattern: getBotPattern(botNumber),
            patternPhase: 0,
            patternCenter: {...position},
            isDragging: false
        };
    }

    // Get pattern type based on bot number
    function getBotPattern(botNumber) {
        const patterns = ['circle', 'figure8', 'linear'];
        return patterns[botNumber - 1] || 'circle';
    }

    // Get predetermined spawn position based on bot number
    function getBotSpawnPosition(botNumber) {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        switch(botNumber) {
            case 1: // Near (150px from center)
                return {x: centerX + 100, y: centerY};
            case 2: // Medium (300px from center, diagonal)
                return {x: centerX + 212, y: centerY + 212};
            case 3: // Far (450px from center, bottom)
                return {x: centerX, y: centerY + 450};
            default:
                return {x: centerX, y: centerY};
        }
    }

    // Spawn test bots
    function spawnTestBots(numBots) {
        testBots = {};

        for (let i = 1; i <= numBots; i++) {
            const botId = `bot-${i}`;
            const position = getBotSpawnPosition(i);
            const bot = createBot(botId, i, position);
            testBots[botId] = bot;

            // Initialize position in positions map
            positions[botId] = bot.position;

            console.log(`Spawned ${bot.name} at (${position.x}, ${position.y})`);
        }
    }

    // Remove all test bots
    function removeTestBots() {
        Object.keys(testBots).forEach(botId => {
            stopBotAudio(botId);
            delete positions[botId];
            delete speakingStates[botId];
        });
        testBots = {};
        console.log('Removed all test bots');
    }

    // Stop audio for a specific bot
    function stopBotAudio(botId) {
        const bot = testBots[botId];
        if (!bot) return;

        // Disconnect and cleanup audio nodes
        if (bot.gainNode) {
            bot.gainNode.disconnect();
            delete gainNodes[botId];
        }
        if (bot.analyzerNode) {
            bot.analyzerNode.disconnect();
            delete analyzerNodes[botId];
        }
        if (bot.audioSource) {
            if (bot.audioSource.stop) bot.audioSource.stop();
            if (bot.audioSource.disconnect) bot.audioSource.disconnect();
        }

        bot.audioSource = null;
        bot.gainNode = null;
        bot.analyzerNode = null;
        bot.audioType = 'silence';
    }

    // ========== Drawing Functions ==========

    // Draw the bar space
    function draw() {
        // Clear canvas
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw all participants
        Object.keys(positions).forEach(peerId => {
            const pos = positions[peerId];
            const isMe = peerId === myPeerId;
            const isSpeaking = speakingStates[peerId];

            // Draw pulsing ring if speaking
            if (isSpeaking) {
                const time = Date.now();
                const pulseScale = 1.0 + 0.3 * Math.abs(Math.sin(time / 300));
                const ringRadius = 30 * pulseScale;

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, ringRadius, 0, Math.PI * 2);
                ctx.strokeStyle = isMe ? '#4a9effaa' : '#ff9e4aaa';
                ctx.lineWidth = 4;
                ctx.stroke();
            }

            // Draw circle for user
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 20, 0, Math.PI * 2);
            ctx.fillStyle = isMe ? '#4a9eff' : '#ff9e4a';
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw label
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            const label = isMe ? 'You' : peerId.substring(0, 6);
            ctx.fillText(label, pos.x, pos.y - 30);
        });

        // Draw hearing range circle around me
        if (myPeerId && positions[myPeerId]) {
            const pos = positions[myPeerId];
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, maxHearingRange, 0, Math.PI * 2);
            ctx.strokeStyle = '#4a9eff44';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    // Broadcast my position to all peers
    function broadcastPosition() {
        Object.keys(connections).forEach(peerId => {
            const conn = connections[peerId]?.conn;
            if (conn && conn.open) {
                conn.send({
                    type: 'position',
                    peerId: myPeerId,
                    x: myPosition.x,
                    y: myPosition.y
                });
            }
        });
    }

    // Detect if audio is being produced
    function detectSpeaking(peerId) {
        const analyzer = analyzerNodes[peerId];
        if (!analyzer) return false;

        const dataArray = new Uint8Array(analyzer.frequencyBinCount);
        analyzer.getByteFrequencyData(dataArray);

        // Calculate RMS (root mean square) volume
        let sumSquares = 0;
        for (let i = 0; i < dataArray.length; i++) {
            const normalized = dataArray[i] / 255.0;
            sumSquares += normalized * normalized;
        }
        const rms = Math.sqrt(sumSquares / dataArray.length);

        // Speaking threshold
        const threshold = 0.02;
        return rms > threshold;
    }

    // Update speaking states for all peers
    function updateSpeakingStates() {
        Object.keys(analyzerNodes).forEach(peerId => {
            speakingStates[peerId] = detectSpeaking(peerId);
        });
    }

    // Animation loop
    function animate() {
        handleKeyboardMovement();
        updateSpeakingStates();
        draw();

        // Update status with user count and nearest peer info
        if (myPeerId && currentRoom) {
            const userCount = Object.keys(participants).length;
            const nearestInfo = getNearestPeerInfo();

            if (nearestInfo) {
                updateStatus(
                    `${userCount} user${userCount !== 1 ? 's' : ''} in room | ` +
                    `Nearest: ${nearestInfo.peerId} (${nearestInfo.distance}px, ${nearestInfo.volume}% volume)`
                );
            } else {
                updateStatus(`${userCount} user${userCount !== 1 ? 's' : ''} in room | Waiting for others to join...`);
            }
        }

        requestAnimationFrame(animate);
    }
    animate();

    function updateStatus(message) {
        statusDiv.textContent = `Status: ${message}`;
        console.log(message);
    }

    function updateConnectionState(state, color) {
        connectionStateEl.textContent = state;
        connectionStateEl.style.background = color;
    }

    // Get nearest peer info for status
    function getNearestPeerInfo() {
        if (!myPeerId || !positions[myPeerId]) return null;

        const myPos = positions[myPeerId];
        let nearest = null;
        let minDistance = Infinity;

        Object.keys(positions).forEach(peerId => {
            if (peerId !== myPeerId && positions[peerId]) {
                const distance = calculateDistance(myPos, positions[peerId]);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearest = peerId;
                }
            }
        });

        if (nearest) {
            const gain = calculateGain(minDistance);
            return {
                peerId: nearest.substring(0, 6),
                distance: Math.round(minDistance),
                volume: Math.round(gain * 100)
            };
        }
        return null;
    }

    function updateParticipantList() {
        participantListEl.innerHTML = '';
        Object.keys(participants).forEach(peerId => {
            const li = document.createElement('li');
            li.textContent = `${participants[peerId].name || peerId.substring(0, 8)}`;
            li.style.padding = '5px';
            participantListEl.appendChild(li);
        });
    }

    // Join room
    joinRoomBtn.addEventListener('click', async () => {
        const roomCode = roomCodeInput.value.trim();
        if (!roomCode) {
            updateStatus('Error: Please enter a room code');
            updateConnectionState('Not Connected', '#cc0000');
            return;
        }

        try {
            // Get microphone
            updateStatus('Requesting microphone access...');
            updateConnectionState('Connecting...', '#ff9e4a');
            localStream = await navigator.mediaDevices.getUserMedia({
                audio: true,
                video: false
            });
            updateStatus('Microphone access granted');
            updateConnectionState('Setting up...', '#ff9e4a');

            // Create audio context for spatial audio
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            updateStatus('Audio context created');

            // Create analyzer for local microphone
            const localSource = audioContext.createMediaStreamSource(localStream);
            const localAnalyzer = audioContext.createAnalyser();
            localAnalyzer.fftSize = 256;
            localAnalyzer.smoothingTimeConstant = 0.8;
            localSource.connect(localAnalyzer);
            // Note: Don't connect to destination (would cause echo)

            // Create peer with room code as ID prefix
            const timestamp = Date.now().toString(36);
            const random = Math.random().toString(36).substring(2, 6);
            const peerId = `${roomCode}-${timestamp}-${random}`;

            peer = new Peer(peerId);

            peer.on('open', (id) => {
                myPeerId = id;
                currentRoom = roomCode;
                updateConnectionState('Connected', '#00cc00');
                roomDisplayEl.style.display = 'inline';
                roomNameEl.textContent = roomCode;
                updateStatus(`Joined room: ${roomCode}`);

                // Initialize my position
                positions[myPeerId] = myPosition;

                // Store local analyzer
                analyzerNodes[myPeerId] = localAnalyzer;

                // Add self to participants
                participants[myPeerId] = { name: 'Me' };
                updateParticipantList();

                // Try to connect to room host
                const hostId = roomCode; // Host uses room code as peer ID
                if (id !== hostId) {
                    connectToHost(hostId);
                } else {
                    updateStatus(`Created room as host: ${roomCode}`);
                }

                joinRoomBtn.disabled = true;
                roomCodeInput.disabled = true;
                muteBtnEl.disabled = false;
            });

            peer.on('error', (err) => {
                if (err.type === 'unavailable-id') {
                    // Room host exists, that's fine
                    console.log('Host peer ID taken, joining as participant');
                } else if (err.type === 'peer-unavailable') {
                    updateStatus(`Error: Cannot connect to peer - they may have left the room`);
                    updateConnectionState('Connection Error', '#cc6600');
                    console.error('Peer unavailable:', err);
                } else if (err.type === 'network') {
                    updateStatus(`Error: Network connection failed - check your internet or firewall`);
                    updateConnectionState('Network Error', '#cc0000');
                    console.error('Network error:', err);
                } else if (err.type === 'server-error') {
                    updateStatus(`Error: Signaling server error - try again in a moment`);
                    updateConnectionState('Server Error', '#cc0000');
                    console.error('Server error:', err);
                } else {
                    updateStatus(`Error: ${err.type} - ${err.message}`);
                    updateConnectionState('Error', '#cc0000');
                    console.error('Peer error:', err);
                }
            });

            // Handle incoming calls
            peer.on('call', (call) => {
                console.log(`Incoming call from ${call.peer}`);
                call.answer(localStream);

                call.on('stream', (remoteStream) => {
                    console.log(`Receiving audio from ${call.peer}`);
                    playAudio(remoteStream, call.peer);
                });

                call.on('close', () => {
                    console.log(`Call closed with ${call.peer}`);
                    if (gainNodes[call.peer]) {
                        gainNodes[call.peer].disconnect();
                        delete gainNodes[call.peer];
                    }
                    if (analyzerNodes[call.peer]) {
                        analyzerNodes[call.peer].disconnect();
                        delete analyzerNodes[call.peer];
                    }
                    delete speakingStates[call.peer];
                    console.log(`Cleaned up audio nodes for ${call.peer}`);
                });

                if (!connections[call.peer]) {
                    connections[call.peer] = {};
                }
                connections[call.peer].call = call;
            });

            // Handle incoming data connections
            peer.on('connection', (conn) => {
                setupDataConnection(conn);
            });

        } catch (err) {
            if (err.name === 'NotAllowedError') {
                updateStatus(`Error: Microphone access denied - please allow microphone in browser settings`);
                updateConnectionState('Mic Denied', '#cc0000');
            } else if (err.name === 'NotFoundError') {
                updateStatus(`Error: No microphone found - please connect a microphone`);
                updateConnectionState('No Mic', '#cc0000');
            } else if (err.name === 'NotReadableError') {
                updateStatus(`Error: Microphone in use by another application`);
                updateConnectionState('Mic Busy', '#cc0000');
            } else {
                updateStatus(`Error: ${err.message}`);
                updateConnectionState('Error', '#cc0000');
            }
            console.error('Setup error:', err);
        }
    });

    // Connect to room host
    function connectToHost(hostId) {
        updateStatus(`Connecting to room host...`);

        // Open data connection to host
        const conn = peer.connect(hostId);
        setupDataConnection(conn);

        // Call host for audio
        const call = peer.call(hostId, localStream);
        call.on('stream', (remoteStream) => {
            playAudio(remoteStream, hostId);
        });

        call.on('close', () => {
            console.log(`Call closed with ${hostId}`);
            if (gainNodes[hostId]) {
                gainNodes[hostId].disconnect();
                delete gainNodes[hostId];
            }
            if (analyzerNodes[hostId]) {
                analyzerNodes[hostId].disconnect();
                delete analyzerNodes[hostId];
            }
            delete speakingStates[hostId];
            console.log(`Cleaned up audio nodes for ${hostId}`);
        });

        connections[hostId] = { call, conn };
    }

    // Setup data connection for participant discovery
    function setupDataConnection(conn) {
        conn.on('open', () => {
            console.log(`Data connection opened with ${conn.peer}`);

            // Send hello with my peer ID
            conn.send({
                type: 'hello',
                peerId: myPeerId,
                room: currentRoom
            });

            // Send current position
            if (myPosition) {
                conn.send({
                    type: 'position',
                    peerId: myPeerId,
                    x: myPosition.x,
                    y: myPosition.y
                });
            }

            if (!connections[conn.peer]) {
                connections[conn.peer] = {};
            }
            connections[conn.peer].conn = conn;

            // Add to participants
            participants[conn.peer] = { name: conn.peer.substring(0, 8) };
            updateParticipantList();
        });

        conn.on('data', (data) => {
            handleDataMessage(data, conn.peer);
        });

        conn.on('close', () => {
            console.log(`Data connection closed with ${conn.peer}`);
            delete connections[conn.peer];
            delete participants[conn.peer];
            delete positions[conn.peer];

            // Clean up audio nodes
            if (gainNodes[conn.peer]) {
                gainNodes[conn.peer].disconnect();
                delete gainNodes[conn.peer];
            }
            if (analyzerNodes[conn.peer]) {
                analyzerNodes[conn.peer].disconnect();
                delete analyzerNodes[conn.peer];
            }
            delete speakingStates[conn.peer];
            console.log(`Cleaned up audio nodes for ${conn.peer}`);

            updateParticipantList();

            // Update status if we're alone now
            if (Object.keys(participants).length === 1) {
                updateStatus(`1 user in room | Waiting for others to join...`);
            }
        });
    }

    // Handle incoming data messages
    function handleDataMessage(data, fromPeer) {
        console.log('Received data:', data, 'from:', fromPeer);

        if (data.type === 'hello') {
            // Someone joined, send them current participant list
            const conn = connections[fromPeer]?.conn;
            if (conn) {
                conn.send({
                    type: 'participants',
                    list: Object.keys(participants)
                });
            }

            // If I'm host, broadcast new participant to others
            if (myPeerId === currentRoom) {
                Object.keys(connections).forEach(peerId => {
                    if (peerId !== fromPeer && connections[peerId].conn) {
                        connections[peerId].conn.send({
                            type: 'new_participant',
                            peerId: data.peerId
                        });
                    }
                });
            }
        } else if (data.type === 'participants') {
            // Received participant list, connect to each
            data.list.forEach(peerId => {
                if (peerId !== myPeerId && !connections[peerId]) {
                    connectToPeer(peerId);
                }
            });
        } else if (data.type === 'new_participant') {
            // New participant joined, connect to them
            if (data.peerId !== myPeerId && !connections[data.peerId]) {
                connectToPeer(data.peerId);
            }
        } else if (data.type === 'position') {
            // Update peer position
            positions[data.peerId] = { x: data.x, y: data.y };
            // Update spatial audio when peer moves
            updateSpatialAudio();
        }
    }

    // Connect to a specific peer
    function connectToPeer(peerId) {
        console.log(`Connecting to peer: ${peerId}`);

        // Data connection
        const conn = peer.connect(peerId);
        setupDataConnection(conn);

        // Audio call
        const call = peer.call(peerId, localStream);
        call.on('stream', (remoteStream) => {
            playAudio(remoteStream, peerId);
        });

        connections[peerId] = { call, conn };
    }

    // Play audio with spatial processing
    async function playAudio(stream, peerId) {
        if (!audioContext) {
            console.error('Audio context not initialized');
            return;
        }

        // Check if audio already playing for this peer
        if (gainNodes[peerId]) {
            console.warn(`Audio already playing for ${peerId}, cleaning up old nodes`);
            gainNodes[peerId].disconnect();
            delete gainNodes[peerId];
        }
        if (analyzerNodes[peerId]) {
            analyzerNodes[peerId].disconnect();
            delete analyzerNodes[peerId];
        }

        // Resume audio context if suspended
        if (audioContext.state === 'suspended') {
            try {
                await audioContext.resume();
                console.log('AudioContext resumed');
            } catch (err) {
                console.error('Failed to resume AudioContext:', err);
            }
        }

        try {
            // Create audio source from remote stream
            const source = audioContext.createMediaStreamSource(stream);

            // Create analyzer for speaking detection
            const analyzer = audioContext.createAnalyser();
            analyzer.fftSize = 256;
            analyzer.smoothingTimeConstant = 0.8;

            // Create gain node for volume control
            const gainNode = audioContext.createGain();
            gainNode.gain.value = 1.0; // Start at full volume

            // Connect: source -> analyzer -> gain -> destination
            source.connect(analyzer);
            analyzer.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Store nodes
            gainNodes[peerId] = gainNode;
            analyzerNodes[peerId] = analyzer;

            console.log(`Audio connected for ${peerId}`);

            // Initialize their position if not set
            if (!positions[peerId]) {
                positions[peerId] = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height
                };
            }

            // Update volume based on distance
            updateSpatialAudio();

        } catch (err) {
            console.error('Error setting up spatial audio:', err);
            // Handle autoplay policy
            updateStatus('Click anywhere to enable audio');
            document.body.addEventListener('click', () => {
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }, { once: true });
        }
    }

    // Calculate distance between two points
    function calculateDistance(pos1, pos2) {
        const dx = pos1.x - pos2.x;
        const dy = pos1.y - pos2.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // Calculate gain (volume) based on distance
    function calculateGain(distance) {
        const minGain = 0.0;
        const maxGain = 1.0;

        // Check if out of hearing range
        if (distance >= maxHearingRange) {
            return minGain;
        }

        // Calculate normalized distance (0 to 1)
        const normalizedDistance = distance / maxHearingRange;

        // Apply falloff curve
        // falloffCurve = 1.0: linear falloff
        // falloffCurve > 1.0: exponential falloff (steeper, sounds drop off faster)
        // falloffCurve < 1.0: logarithmic falloff (gentler, sounds carry further)
        const falloff = Math.pow(normalizedDistance, falloffCurve);

        return maxGain - falloff;
    }

    // Update spatial audio for all peers
    function updateSpatialAudio() {
        if (!myPeerId || !positions[myPeerId]) return;

        const myPos = positions[myPeerId];

        Object.keys(gainNodes).forEach(peerId => {
            if (positions[peerId]) {
                const peerPos = positions[peerId];
                const distance = calculateDistance(myPos, peerPos);
                const gain = calculateGain(distance);

                // Update gain node
                gainNodes[peerId].gain.value = gain;
            }
        });
    }

    // Mute toggle
    muteBtnEl.addEventListener('click', () => {
        isMuted = !isMuted;
        localStream.getAudioTracks().forEach(track => {
            track.enabled = !isMuted;
        });
        muteBtnEl.textContent = isMuted ? 'Unmute' : 'Mute';
        updateStatus(isMuted ? 'Muted' : 'Unmuted');
    });

    // Hearing range slider
    hearingRangeSlider.addEventListener('input', (e) => {
        maxHearingRange = parseInt(e.target.value);
        hearingRangeValue.textContent = `${maxHearingRange}px`;
        updateSpatialAudio();
    });

    // Falloff curve slider
    falloffSlider.addEventListener('input', (e) => {
        falloffCurve = parseFloat(e.target.value);
        falloffValue.textContent = falloffCurve.toFixed(1);
        updateSpatialAudio();
    });
    </script>
</body>
</html>
