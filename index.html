<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sounds of STFU - POC</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a1a;
            color: #ffffff;
        }
        #controls {
            margin-bottom: 20px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 8px;
        }
        input, button {
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
        }
        input {
            background: #3a3a3a;
            color: #ffffff;
            min-width: 200px;
        }
        button {
            background: #4a9eff;
            color: #ffffff;
            cursor: pointer;
        }
        button:hover {
            background: #3a8eef;
        }
        button:disabled {
            background: #555555;
            cursor: not-allowed;
        }
        #status {
            margin: 10px 5px;
            padding: 10px;
            background: #333333;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        #barCanvas {
            display: block;
            background: #2a2a2a;
            border: 2px solid #4a4a4a;
            border-radius: 8px;
            cursor: crosshair;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h1>Sounds of STFU - POC</h1>
        <div>
            <input type="text" id="roomCode" placeholder="Enter room code (or create new)">
            <button id="joinRoom">Join Room</button>
        </div>
        <div>
            <button id="muteBtn" disabled>Mute</button>
        </div>
        <div id="status">Status: Not connected</div>
        <div id="participants" style="margin-top: 10px; padding: 10px; background: #333; border-radius: 4px;">
            <strong>Participants:</strong>
            <ul id="participantList" style="list-style: none; padding: 0;"></ul>
        </div>
    </div>

    <canvas id="barCanvas" width="800" height="600"></canvas>

    <script src="https://unpkg.com/peerjs@1.5.0/dist/peerjs.min.js"></script>
    <script>
    let peer = null;
    let localStream = null;
    let myPeerId = null;
    let currentRoom = null;
    let connections = {}; // { peerId: { call: MediaConnection, conn: DataConnection } }
    let participants = {}; // { peerId: { name: string } }
    let isMuted = false;

    const roomCodeInput = document.getElementById('roomCode');
    const joinRoomBtn = document.getElementById('joinRoom');
    const muteBtnEl = document.getElementById('muteBtn');
    const statusDiv = document.getElementById('status');
    const participantListEl = document.getElementById('participantList');

    const canvas = document.getElementById('barCanvas');
    const ctx = canvas.getContext('2d');

    let positions = {}; // { peerId: { x, y } }
    let myPosition = { x: 400, y: 300 }; // Start in center

    let audioContext = null;
    let gainNodes = {}; // { peerId: GainNode }

    // Initialize my position
    positions[myPeerId] = myPosition;

    // Canvas click to move
    canvas.addEventListener('click', (e) => {
        if (!myPeerId) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        myPosition = { x, y };
        positions[myPeerId] = myPosition;

        // Broadcast position to all peers
        broadcastPosition();

        // Update spatial audio based on new position
        updateSpatialAudio();

        draw();
    });

    // Draw the bar space
    function draw() {
        // Clear canvas
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw all participants
        Object.keys(positions).forEach(peerId => {
            const pos = positions[peerId];
            const isMe = peerId === myPeerId;

            // Draw circle for user
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 20, 0, Math.PI * 2);
            ctx.fillStyle = isMe ? '#4a9eff' : '#ff9e4a';
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw label
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            const label = isMe ? 'You' : peerId.substring(0, 6);
            ctx.fillText(label, pos.x, pos.y - 30);
        });

        // Draw hearing range circle around me
        if (myPeerId && positions[myPeerId]) {
            const pos = positions[myPeerId];
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 200, 0, Math.PI * 2);
            ctx.strokeStyle = '#4a9eff44';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    // Broadcast my position to all peers
    function broadcastPosition() {
        Object.keys(connections).forEach(peerId => {
            const conn = connections[peerId]?.conn;
            if (conn && conn.open) {
                conn.send({
                    type: 'position',
                    peerId: myPeerId,
                    x: myPosition.x,
                    y: myPosition.y
                });
            }
        });
    }

    // Animation loop
    function animate() {
        draw();
        requestAnimationFrame(animate);
    }
    animate();

    function updateStatus(message) {
        statusDiv.textContent = `Status: ${message}`;
        console.log(message);
    }

    function updateParticipantList() {
        participantListEl.innerHTML = '';
        Object.keys(participants).forEach(peerId => {
            const li = document.createElement('li');
            li.textContent = `${participants[peerId].name || peerId.substring(0, 8)}`;
            li.style.padding = '5px';
            participantListEl.appendChild(li);
        });
    }

    // Join room
    joinRoomBtn.addEventListener('click', async () => {
        const roomCode = roomCodeInput.value.trim();
        if (!roomCode) {
            updateStatus('Please enter a room code');
            return;
        }

        try {
            // Get microphone
            updateStatus('Requesting microphone access...');
            localStream = await navigator.mediaDevices.getUserMedia({
                audio: true,
                video: false
            });
            updateStatus('Microphone access granted');

            // Create audio context for spatial audio
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            updateStatus('Audio context created');

            // Create peer with room code as ID prefix
            const timestamp = Date.now().toString(36);
            const random = Math.random().toString(36).substring(2, 6);
            const peerId = `${roomCode}-${timestamp}-${random}`;

            peer = new Peer(peerId);

            peer.on('open', (id) => {
                myPeerId = id;
                currentRoom = roomCode;
                updateStatus(`Joined room: ${roomCode}`);

                // Add self to participants
                participants[myPeerId] = { name: 'Me' };
                updateParticipantList();

                // Try to connect to room host
                const hostId = roomCode; // Host uses room code as peer ID
                if (id !== hostId) {
                    connectToHost(hostId);
                } else {
                    updateStatus(`Created room as host: ${roomCode}`);
                }

                joinRoomBtn.disabled = true;
                roomCodeInput.disabled = true;
                muteBtnEl.disabled = false;
            });

            peer.on('error', (err) => {
                if (err.type === 'unavailable-id') {
                    // Room host exists, that's fine
                    console.log('Host peer ID taken, joining as participant');
                } else {
                    updateStatus(`Error: ${err.type} - ${err.message}`);
                    console.error('Peer error:', err);
                }
            });

            // Handle incoming calls
            peer.on('call', (call) => {
                console.log(`Incoming call from ${call.peer}`);
                call.answer(localStream);

                call.on('stream', (remoteStream) => {
                    console.log(`Receiving audio from ${call.peer}`);
                    playAudio(remoteStream, call.peer);
                });

                if (!connections[call.peer]) {
                    connections[call.peer] = {};
                }
                connections[call.peer].call = call;
            });

            // Handle incoming data connections
            peer.on('connection', (conn) => {
                setupDataConnection(conn);
            });

        } catch (err) {
            updateStatus(`Error: ${err.message}`);
            console.error('Setup error:', err);
        }
    });

    // Connect to room host
    function connectToHost(hostId) {
        updateStatus(`Connecting to room host...`);

        // Open data connection to host
        const conn = peer.connect(hostId);
        setupDataConnection(conn);

        // Call host for audio
        const call = peer.call(hostId, localStream);
        call.on('stream', (remoteStream) => {
            playAudio(remoteStream, hostId);
        });

        connections[hostId] = { call, conn };
    }

    // Setup data connection for participant discovery
    function setupDataConnection(conn) {
        conn.on('open', () => {
            console.log(`Data connection opened with ${conn.peer}`);

            // Send hello with my peer ID
            conn.send({
                type: 'hello',
                peerId: myPeerId,
                room: currentRoom
            });

            // Send current position
            if (myPosition) {
                conn.send({
                    type: 'position',
                    peerId: myPeerId,
                    x: myPosition.x,
                    y: myPosition.y
                });
            }

            if (!connections[conn.peer]) {
                connections[conn.peer] = {};
            }
            connections[conn.peer].conn = conn;

            // Add to participants
            participants[conn.peer] = { name: conn.peer.substring(0, 8) };
            updateParticipantList();
        });

        conn.on('data', (data) => {
            handleDataMessage(data, conn.peer);
        });

        conn.on('close', () => {
            console.log(`Data connection closed with ${conn.peer}`);
            delete connections[conn.peer];
            delete participants[conn.peer];
            delete positions[conn.peer];
            updateParticipantList();
        });
    }

    // Handle incoming data messages
    function handleDataMessage(data, fromPeer) {
        console.log('Received data:', data, 'from:', fromPeer);

        if (data.type === 'hello') {
            // Someone joined, send them current participant list
            const conn = connections[fromPeer]?.conn;
            if (conn) {
                conn.send({
                    type: 'participants',
                    list: Object.keys(participants)
                });
            }

            // If I'm host, broadcast new participant to others
            if (myPeerId === currentRoom) {
                Object.keys(connections).forEach(peerId => {
                    if (peerId !== fromPeer && connections[peerId].conn) {
                        connections[peerId].conn.send({
                            type: 'new_participant',
                            peerId: data.peerId
                        });
                    }
                });
            }
        } else if (data.type === 'participants') {
            // Received participant list, connect to each
            data.list.forEach(peerId => {
                if (peerId !== myPeerId && !connections[peerId]) {
                    connectToPeer(peerId);
                }
            });
        } else if (data.type === 'new_participant') {
            // New participant joined, connect to them
            if (data.peerId !== myPeerId && !connections[data.peerId]) {
                connectToPeer(data.peerId);
            }
        } else if (data.type === 'position') {
            // Update peer position
            positions[data.peerId] = { x: data.x, y: data.y };
            // Update spatial audio when peer moves
            updateSpatialAudio();
        }
    }

    // Connect to a specific peer
    function connectToPeer(peerId) {
        console.log(`Connecting to peer: ${peerId}`);

        // Data connection
        const conn = peer.connect(peerId);
        setupDataConnection(conn);

        // Audio call
        const call = peer.call(peerId, localStream);
        call.on('stream', (remoteStream) => {
            playAudio(remoteStream, peerId);
        });

        connections[peerId] = { call, conn };
    }

    // Play audio with spatial processing
    function playAudio(stream, peerId) {
        if (!audioContext) {
            console.error('Audio context not initialized');
            return;
        }

        try {
            // Create audio source from remote stream
            const source = audioContext.createMediaStreamSource(stream);

            // Create gain node for volume control
            const gainNode = audioContext.createGain();
            gainNode.gain.value = 1.0; // Start at full volume

            // Connect: source -> gain -> destination
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Store gain node for this peer
            gainNodes[peerId] = gainNode;

            console.log(`Audio connected for ${peerId}`);

            // Initialize their position if not set
            if (!positions[peerId]) {
                positions[peerId] = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height
                };
            }

            // Update volume based on distance
            updateSpatialAudio();

        } catch (err) {
            console.error('Error setting up spatial audio:', err);
            // Handle autoplay policy
            updateStatus('Click anywhere to enable audio');
            document.body.addEventListener('click', () => {
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }, { once: true });
        }
    }

    // Calculate distance between two points
    function calculateDistance(pos1, pos2) {
        const dx = pos1.x - pos2.x;
        const dy = pos1.y - pos2.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // Calculate gain (volume) based on distance
    function calculateGain(distance) {
        const maxHearingRange = 300; // pixels
        const minGain = 0.0;
        const maxGain = 1.0;

        // Linear falloff
        if (distance >= maxHearingRange) {
            return minGain;
        }

        return maxGain - (distance / maxHearingRange);
    }

    // Update spatial audio for all peers
    function updateSpatialAudio() {
        if (!myPeerId || !positions[myPeerId]) return;

        const myPos = positions[myPeerId];

        Object.keys(gainNodes).forEach(peerId => {
            if (positions[peerId]) {
                const peerPos = positions[peerId];
                const distance = calculateDistance(myPos, peerPos);
                const gain = calculateGain(distance);

                // Update gain node
                gainNodes[peerId].gain.value = gain;
            }
        });
    }

    // Mute toggle
    muteBtnEl.addEventListener('click', () => {
        isMuted = !isMuted;
        localStream.getAudioTracks().forEach(track => {
            track.enabled = !isMuted;
        });
        muteBtnEl.textContent = isMuted ? 'Unmute' : 'Mute';
        updateStatus(isMuted ? 'Muted' : 'Unmuted');
    });
    </script>
</body>
</html>
